#!/usr/bin/env zsh

(( $+functions[_manage_fallback] )) || _manage_fallback () {
    if zstyle -T ":completion:${curcontext}:" use-fallback; then
        _path_files
        ret=$?
    else
        _message 'Unknown sub-command'
    fi
}
(( $+functions[_manage] )) || _manage_execute () {
    local _manage_result
    _manage_result="${(@f)$(manage completion "$@" || echo "")}"
    _cache_invalid "${key}" || true
    _store_cache "${key}" _manage_result
}

(( $+functions[_manage_get] )) || _manage_get () {
    local _manage_result
    local key

    key="$(echo "${PWD}${@}" | md5sum)"
    key="${key[0,32]}"

    if _retrieve_cache "${key}"
    then
        true
    else
        _manage_execute "$@"
        _retrieve_cache "${key}"
    fi

    echo "$_manage_result"

    {
        _manage_execute "$@" > /dev/null 2>&1 &!
    }
}

(( $+functions[_manage] )) || _manage () {
    local curcontext="$curcontext" state line cmds ret=1

    _arguments -C \
        '1: :->cmds' \
        '*: :->args' && ret=0

    local _script
    local -a _names
    local completions

    scripts=("${(@f)$(_manage_get)}")

    for _script in $scripts[@]
    do
        _script=("${(s/:/)_script}")
        _names+=("${_script[1]}")
    done

    case "$state" in
        (cmds)
            _describe -t scripts 'scripts' scripts && ret=0
            ;;
        (args)
            if (( ${_names[(I)${line[1]}]} ))
            then
                local prev
                local cmd
                cmd="${line[1]}"
                prev="${words[CURRENT-1]}"

                if  [[ -z "${prev}" ]]
                then
                    completions=("${(@f)$(_manage_get "${cmd}")}")
                else
                    completions=("${(@f)$(_manage_get "${cmd}" "${prev}")}")
                fi

                if  [ -z "${completions}" ]
                then
                    _manage_fallback
                else
                    _describe -t completions "${cmd}" completions && ret=0
                fi
            else
                _manage_fallback
            fi
            ;;
    esac

    return ret
}
