#!/usr/bin/env bash
#
# @doc manage is a convention for setting up shell programs that use subcommands.
#
# For more details on how to define your own commands
# look online at https://github.com/epiloque/manage
#
# shellcheck disable=SC1090,SC2016,SC2034
# @dependency bc
# @dependency cut
# @dependency find
# @dependency fold
# @dependency grep
# @dependency head
# @dependency printf
# @dependency rev
# @dependency sed
# @dependency seq
# @dependency sort
# @dependency tr

if ((BASH_VERSINFO[0] >= 4)) &&
   ((BASH_VERSINFO[1] >= 2))
then
    true
else
    echo "You need at least GNU bash, version 4.2" >&2
    exit 1
fi

sed ()
{
    if command -v "gsed" > /dev/null 2>&1
    then
        command gsed "$@"
    else
        command sed "$@"
    fi
}

strict()
{
    # set/unset strict mode
    #
    # Usage: strict true/false
    #

    local value
    value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
    case "${value}" in
        no|n|false|f|off|0)
            set   +o errexit
            set   +o errtrace
            set   +o pipefail
            shopt -u nullglob
            IFS=$' \n\t'
            ;;
        *)
            set   -o errexit
            set   -o errtrace
            set   -o pipefail
            shopt -s nullglob
            IFS=$'\n\t'
    esac
}

verbose()
{
    #
    # With no arguments, test if verbose mode is enabled.
    # With one argument, set/unset verbose mode.
    #

    if (( $# == 0 )); then
        [ -n "${MANAGEVERBOSE}" ] && return "${MANAGEVERBOSE}"
        return 1
    else
        local value
        value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
        case "${value}" in
            no|n|false|f|off|0)
                MANAGEVERBOSE=1
                ;;
            *)
                MANAGEVERBOSE=0
        esac
    fi
}

declare -A MANAGE_MODULE_NAMES
declare -A MANAGE_MODULES
declare -A MANAGE_REMOTES
declare -A MANAGE_PATHS

MANAGE_ERROR () {
    local type="$1"; shift
    local prefix=$'\033[1m\033[31mERROR\033[39m\033[0m'

    case "${type}" in
        notDefined)
            printf "%s '%s' is not defined\n" "${prefix}" "$@" >&2
        ;;
        notRepository)
            printf "%s '%s' is not a valid manage repository\n" "${prefix}" "$@" >&2
        ;;
        diffVersion)
            printf "%s at least two different versions requested for the '%s' repository\n" "${prefix}" "$@" >&2
        ;;
        failDownload)
            printf "%s failed to download repository '%s'\n" "${prefix}" "$@" >&2
        ;;
        invalidQuery)
            printf "%s invalid option '%s' in query '%s'\n" "${prefix}" "$@" >&2
        ;;
        invalidVersion)
            printf "%s version options in query '%s'\nmust match the pattern '%s'\n" "${prefix}" "$@" >&2
        ;;
        failImport)
            printf "%s failed to import '%s': No such file or directory\n" "${prefix}" "$@" >&2
        ;;
        collision)
            printf "%s the same name is used by two different functions\n '%s' and '%s'\n" "${prefix}" "$@" >&2
        ;;
        failVerify)
            printf "%s failed to verify repository '%s' with tag '%s'\n" "${prefix}" "$@" >&2
        ;;
        *)
            printf "%s uncaught exception\n" "${prefix}" >&2
    esac

    exit 1
}

MANAGE_BOOTSTRAP () {
    local namespace

    eval "$(
        echo 'MANAGE_RUNTIME () (
        strict true
        '

        echo "${MANAGE_NAMESPACE}"

        echo '
            local ___func="$1"
            shift

            if [[ "$(type -t "${___func}")" = "function" ]]
            then
                "${___func}" "$@" || return $?
                return $?
            else
                return 1
            fi
        )
        '
    )"
}

_ () {
    if [[ -n "${1}" ]] &&
       [[ -n "${MANAGE_MODULE_NAMES["${1}"]}" ]]
    then
        MANAGE_RUNTIME "$@"
    else
        MANAGE_ERROR notDefined "$1"
    fi
}

MANAGE_GET_FUNCTION () (
    source "${1}"
    declare -f "${2}"
)

MANAGE_SOURCE () {
    local mode="$1"
    local file="$2"
    local script="$3"
    local longName="$4"
    local name


    name="$(basename "${script}")"

    if [[ -z "${MANAGE_MODULE_NAMES["${name}"]}" ]]
    then
        MANAGE_MODULE_NAMES["${name}"]="${longName}"
    else
        MANAGE_ERROR collision "${longName}" "${MANAGE_MODULE_NAMES["${name}"]}"
    fi

    if [[ "${mode}" = "underscore" ]]
    then
        MANAGE_NAMESPACE+="$(MANAGE_GET_FUNCTION "${file}" "${name}")"$'\n' ||
            MANAGE_ERROR failImport "${longName}"
    elif [[ "${mode}" = "local" ]]
    then
        source "${file}" || MANAGE_ERROR failImport "${longName}"
    fi
}

MANAGE_TAG ()
{
    local tag=${1}; shift
    local trim='s/^[ \t]*//;s/[ \t]*$//'
    local comment='^[ \t]*[#]+[ \t]*'
    local import='[-_a-zA-Z0-9]+\/[-_a-zA-Z0-9]+|github.com\/[-a-z0-9]{0,39}\/[-_a-zA-Z0-9]+\/[-_a-zA-Z0-9]+\/[-_a-zA-Z0-9]+(\?[a-zA-Z0-9]+=[a-zA-Z0-9\.]+)*'
    local dependency='[-_a-zA-Z0-9]+'

    case "$tag" in
        import)
            sed -nr "s/${comment}@${tag} (${import})$/\1/p;${trim}" "$@"
        ;;
        dependency)
            sed -nr "s/${comment}*@${tag} (${dependency})$/\1/p;${trim}" "$@"
        ;;
        *)
            sed -nr "s/${comment}*@${tag} (.+)$/\1/p;${trim}" "$@"
    esac
}

MANAGE_GET () {
    local repository="$1"
    local version="$2"
    local directory="$3"
    local verify="$4"
    local modulePath

    local localVersion

    local lsRemoteRegex="^[a-z0-9]{40}[\t ]+refs\/tags\/v([0-9]+)\.([0-9]+)\.([0-9]+)([0-9A-Za-z-])?"
    local state=1

    if [[ -n "${MANAGE_REMOTES["${repository}"]}" ]]
    then
        [[ "${MANAGE_REMOTES["${repository}"]}" != "${version}" ]] && {
            MANAGE_ERROR diffVersion "${repository}"
        }
    else
        if [ -d "${directory}" ] &&
           [ -f "${directory}/.manage.yml" ] &&
           cd "${directory}" &&
           [[ "$(git remote get-url origin)" = "${repository}" ]] &&
           localVersion="$(git describe --tags | head -n 1)"
        then
            if [[ "${verify}" = "false" ]]
            then
                state=0
                MANAGE_REMOTES["${repository}"]="${version}"
            else
                cd "${directory}" &&
                git tag -v "${localVersion}" &> /dev/null &&
                state=0 &&
                MANAGE_REMOTES["${repository}"]="${version}"
            fi

            [[ "${version}" != "latest" ]] &&
            [[ "${version}" != "${localVersion}" ]] &&
            state=1
        fi
    fi

    if [[ "${state}" = 1 ]]
    then
        (
            rm -rf "${directory}"
            mkdir -p "${directory}"
            cd "${directory}"

            git init -q "${directory}"
            GIT_TERMINAL_PROMPT=0 git remote add origin "${repository}"

            if [[ "${version}" = "latest" ]]
            then
                version="$(
                    git ls-remote --refs -t -h -q |
                    sed -r -n "/${lsRemoteRegex}/p" |
                    LC_ALL=C sort -r -t '/' -k 3 -V |
                    head -n 1 |
                    cut -d '/' -f 3
                )"
            fi

            git fetch -q --depth=1 --recurse-submodules=yes origin tag "${version}"
            git checkout -q "${version}"
            git submodule --quiet update --depth 1 --init --recursive

            if [[ "${verify}" = "true" ]]
            then
                git tag -v "${version}" &> /dev/null || {
                    rm -rf "${directory}"
                    MANAGE_ERROR failVerify "${repository}" "${version}"
                }
            fi
        ) || return 1

        MANAGE_REMOTES["${repository}"]="${1}"
    fi

    if [[ ! -n "${MANAGE_PATHS["${repository}"]}" ]]
    then
        [ ! -f "${directory}/.manage.yml" ] && {
            rm -rf "${directory}" || true
            MANAGE_ERROR notRepository "${repository}"
        }

        modulePath="$(
            awk '
                !/^[[:blank:]]/ {unindented = $0}
                /module: / && /^[[:blank:]]/ {
                    if (unindented == "directories:") {
                            gsub(/^[ \t\r\n]+module:[ \t\r\n]+/, "", $0);
                            print;
                    }
                }
            ' "${directory}/.manage.yml"
        )" || modulePath=

        if [ ! -n "${modulePath}" ]
        then
            modulePath="scripts/modules"
        fi

        modulePath="${directory}/${modulePath}"

        [ ! -d "${modulePath}" ] && {
            rm -rf "${directory}" || true
            MANAGE_ERROR notRepository "${repository}"
        }

        MANAGE_PATHS["${repository}"]="${modulePath}"
    fi
}

MANAGE_RESOLVE () {
    if [ -z "${MANAGE_REPOSITORY}" ]
    then
        MANAGE_DOWNLOAD_DIRECTORY="${MANAGE_DIRECTORY}/.manage_modules"
    else
        MANAGE_DOWNLOAD_DIRECTORY="${MANAGE_REPOSITORY}/.manage_modules"
    fi

    [ -z "${MANAGE_PATHS["0"]}" ] && MANAGE_PATHS["0"]="${MANAGE_DIRECTORY}/modules"

    [ -z "${MANAGE_PATHS["1"]}" ] &&
    [ -n "${MANAGE_MODULE_DIRECTORY}" ] &&
    [ "${MANAGE_MODULE_DIRECTORY}" != "${MANAGE_DIRECTORY}/modules" ] &&
    MANAGE_PATHS["1"]="${MANAGE_MODULE_DIRECTORY}"

    local mode="$1";
    local cwd="$2"; shift 2

    local arguments
    local directory
    local file
    local functionName
    local imports
    local repository
    local script
    local scriptName
    local query
    local versionRegex="v([0-9]+)\.([0-9]+)\.([0-9]+)([0-9A-Za-z-])?"

    declare -A scripts
    declare -A manageModules
    declare -A localModules
    declare -A otherModules

    IFS=$'\n ' read -r -a arguments <<< "${@}"

    for script in "${arguments[@]}"
    do
        if  [[ -n "${script}" ]] &&
            [[ -z "${scripts[${script}]}" ]]
        then
            if [[ "${script:0:10}" = "github.com" ]]
            then
                IFS='/?' read -r -a query <<< "$script"

                directory="${MANAGE_DOWNLOAD_DIRECTORY}/${query[1]}/${query[2]}"
                repository="https://${query[0]}/${query[1]}/${query[2]}.git"
                script="${query[0]}/${query[1]}/${query[2]}/${query[3]}/${query[4]}"
                scriptName="${query[3]}/${query[4]}"

                query=("${query[@]:5}")

                local part key value
                local version="latest"
                local verify="true"

                for part in "${query[@]}"
                do
                    key="${part%=*}"
                    value="${part#*=}"

                    case "${key}" in
                        version)
                            if [[ "${value}" =~ ^${versionRegex}$ || "${value}" = "latest" ]]
                            then
                                version="${value}"
                            else
                                MANAGE_ERROR invalidVersion "${script}?${part}" "${versionRegex}"
                            fi
                        ;;
                        verify)
                            case "${value}" in
                                no|n|false|f|off|0)
                                    verify=false
                                    ;;
                                *)
                                    verify=true
                            esac
                        ;;
                        *)
                            MANAGE_ERROR invalidQuery "${part}" "${script}?${part}"
                    esac
                done

                MANAGE_GET "${repository}" "${version}" "${directory}" "${verify}" || {
                    rm -rf "${directory}" || true
                    MANAGE_ERROR failDownload "${repository}"
                }

                scripts["${scriptName}"]="${script}"
            else
                scripts["${script}"]="${script}"
            fi
        fi
    done

    while read -d '' -r file
    do
        for script in "${!scripts[@]}"
        do
            if [[ -z "${MANAGE_MODULES["${script}"]}" ]] &&
               [[ "${file}" =~ ${script}$ ]] &&
               [[ "$(head -n 1 "${file}")" =~ ^(#!){1}.*(bash){1}.* ]] &&
               [[ "$(basename "${file}")" =~ ^[-_a-zA-Z0-9]*$ ]]
            then
                if [[ "${file}" == "${MANAGE_DIRECTORY}/modules/"* ]]
                then
                    manageModules["${script}"]="${file}"
                elif [[ -n "${MANAGE_MODULE_DIRECTORY}" ]] &&
                     [[ "${MANAGE_MODULE_DIRECTORY}" != "${MANAGE_DIRECTORY}" ]] &&
                     [[ "${file}" == "${MANAGE_MODULE_DIRECTORY}/"* ]]
                then
                    localModules["${script}"]="${file}"
                else
                    otherModules["${script}"]="${file}"
                fi
            fi
        done
    done < <(find "${MANAGE_PATHS[@]}" -type f -print0 2> /dev/null)

    for script in "${!manageModules[@]}"
    do
        if [[ -z "${MANAGE_MODULES["${script}"]}" ]]
        then
            file="${manageModules["${script}"]}"
            imports+="$(MANAGE_TAG import "${file}")"
            imports+=$'\n'

            MANAGE_SOURCE "${mode}" "${file}" "${script}" "${scripts["${script}"]}"
            MANAGE_MODULES["${script}"]="${file}"
        fi
    done

    for script in "${!localModules[@]}"
    do
        if [[ -z "${MANAGE_MODULES["${script}"]}" ]]
        then
            file="${localModules["${script}"]}"
            imports+="$(MANAGE_TAG import "${file}")"
            imports+=$'\n'

            MANAGE_SOURCE "${mode}" "${file}" "${script}" "${scripts["${script}"]}"
            MANAGE_MODULES["${script}"]="${file}"
        fi
    done

    # TODO: Failure modes
    for script in "${!otherModules[@]}"
    do
        if [[ -z "${MANAGE_MODULES["${script}"]}" ]]
        then
            file="${otherModules["${script}"]}"
            imports+="$(MANAGE_TAG import "${file}")"
            imports+=$'\n'


            # if [[ ! "${scripts["${script}"]}" =~ ^github\.com ]]
            # then
            #     echo give an error for "${script}"
            #     exit 1
            # fi

            MANAGE_SOURCE "${mode}" "${file}" "${script}" "${scripts["${script}"]}"
            MANAGE_MODULES["${script}"]="${file}"
        else
            true
            # if [[ "${scripts["${script}"]}" =~ ^github\.com ]]
            # then
            #     echo give a warning for "${script}"
            # fi
        fi
    done

    for script in "${!scripts[@]}"
    do
        [ -z "${MANAGE_MODULES["${script}"]}" ] && {
            MANAGE_ERROR failImport "${scripts[${script}]}"
        }
    done

    if [ ! ${#imports} -eq 0 ]
    then
        MANAGE_RESOLVE "${mode}" "${cwd}" "${imports//$'\n'/ }"
    fi

    cd "${cwd}" || exit
}

MANAGE_LOCAL () {
    MANAGE_RESOLVE local "$(pwd)" "$@"
}

MANAGE_UNDERSCORE () {
    MANAGE_RESOLVE underscore "$(pwd)" "$@"
}

MANAGE_ONCE () {
    local __code=0
    "$@" || __code="$?"
    eval "$1"' () { return '"${__code}"'; }'
    return "${__code}"
}

MANAGE_MAIN ()
{
    local _code
    local _function
    if [ -n "${MANAGE_COMPLETION}" ]
    then
        _function="completion"
    else
        _function="main"
    fi

    if declare -f "${_function}" > /dev/null 2>&1
    then
        trap 'MANAGE_ONCE MANAGE_RETURN $?' INT HUP TERM QUIT EXIT
        "${_function}" "$@"
        _code=$?
        trap - INT HUP TERM QUIT EXIT ERR
    fi

    if [ ! -n "${MANAGE_COMPLETION}" ]
    then
        MANAGE_ONCE MANAGE_RETURN "${_code}"
    fi

    return $?
}

MANAGE_RETURN ()
{
    local _code=${1:-0}
    if declare -f "onExit" > /dev/null 2>&1
    then
        onExit "${_code}" || true
    fi

    return "${_code}"
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]
then
    MANAGE_IMPORT_ARRAY=(${MANAGE_IMPORT})

    strict true

    if [ ! ${#MANAGE_IMPORT_ARRAY[@]} -eq 0 ]
    then
        MANAGE_UNDERSCORE "${MANAGE_IMPORT_ARRAY[@]}"
        MANAGE_BOOTSTRAP
    fi

    [ -n "${MANAGE_SCRIPT_PATH}" ] &&
    source "${MANAGE_SCRIPT_PATH}"
    MANAGE_MAIN "$@"
else
    strict true

    resolvelink() {
        $(type -p greadlink readlink | head -1) "$1"
    }

    absolutedirectorypath() {
        local cwd
        local path="$1"

        cwd="$(pwd)"

        while [ -n "$path" ]; do
            cd "${path%/*}" || exit
            local name="${path##*/}"
            path="$(resolvelink "$name" || true)"
        done

        pwd
        cd "${cwd}" || exit
    }

    expandpath() {
        { cd "$(dirname "$1")" 2>/dev/null
            local dirname="$PWD"
            cd "$OLDPWD"
            echo "$dirname/$(basename "$1")"
        } || echo "$1"
    }

    # shellcheck disable=SC2034

    MANAGE_CWD="$(absolutedirectorypath .)"
    MANAGE_ZERO="$(expandpath "$0")"
    MANAGE_LIBEXEC="$(absolutedirectorypath "${MANAGE_ZERO}")"
    MANAGE_DIRECTORY="$(absolutedirectorypath "${MANAGE_LIBEXEC}")"

    LC_ALL=C

    declare -A MANAGE_SCRIPTS

    MANAGE_LOCAL \
        manage/checkFileDependencies \
        manage/collectScripts \
        manage/completion \
        manage/help

    checkFileDependencies "${MANAGE_DIRECTORY}/bin/manage"
    collectScripts "$@"
fi
