#!/usr/bin/env manage
#
# vim: set ft=sh:
#
# <doc>
#
# Build manage
#
# </doc>
#
# <import>
#
# collection-shell
# collection-message
# collection-string
#
# </import>
#
# <dependency>
#
# docker
#
# </dependency>
#
# Environment variables passed by assemble
#
# MANAGE_BUILD
# MANAGE_BUILD_URL
# MANAGE_BUILD_TAG
# MANAGE_BUILD_VERSION
# MANAGE_BUILD_DIRECTORY
# MANAGE_BUILD_REFERENCE
# MANAGE_BUILD_ARTIFACTS
# MANAGE_BUILD_MAINTAINER

build () {
    _required "$1" || return 1
    image="$1"

    _ info "Building '${image}'."

    _ retry "${tries}"    \
      docker build -t     \
      "manage:${image}" . \
      > /dev/null 2>&1    || return 1

    _ info "Running '${image}' tests."

    docker run "manage:${image}" test || return 1
}

main ()
{
    verbose true
    strict true

    local file
    local tries="3"
    local images=()

    cd "${MANAGEDIRECTORY}" || _ die

    local code=0
    for file in "${MANAGEDIRECTORY}/script/build/docker/Dockerfile".*
    do
        [ -f "${MANAGEDIRECTORY}/Dockerfile" ] &&
        rm -f "${MANAGEDIRECTORY}/Dockerfile"

        image="$(grep FROM "${file}")"
        image="${image#FROM }"
        image="${image//:/-}"
        images+=("${image}")

        cp -f "${file}" "${MANAGEDIRECTORY}/Dockerfile"

        build "${image}" || (( ++code ))
    done

    if   _ truth "${MANAGE_BUILD}"       &&
       ! _ truth "${MANAGE_BUILD_WIP}"   &&
       [[ -d "${MANAGE_BUILD_ARTIFACTS}" ]]
       [[  "${code}" == "0"              ]]
    then
        _ info "Pushing for release."
    fi
}

onexit ()
{
    [ -f "${MANAGEDIRECTORY}/Dockerfile" ] &&
    rm -f "${MANAGEDIRECTORY}/Dockerfile"

    # if (( $1 == 0 ))
    # then
    #     _ warn "Exiting."
    # else
    #     _ error "An error with exit code \"$1\" has occured."
    # fi
}
