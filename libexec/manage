#!/usr/bin/env bash
#
# <doc>
#
# _manage is a model for setting up shell programs that use
# subcommands.
#
# For more details on how to define your own commands look
# online at https://github.com/eitherlands/_manage
#
# </doc>
#
# <dependency>
#
# awk
# sed
# tr
# head
# grep
# comm
#
# </dependency>

if ((BASH_VERSINFO[0] < 4))
then
    echo "You need at least GNU bash, version 4." >&2
    exit 1
fi

__ ()
{
    local ___one="$1"
    shift

    [ -z "${MANAGEIMPORTPATHS}" ] && MANAGEIMPORTPATHS=("${MANAGEDIRECTORY}/common" "${MANAGEDIRECTORY}/payload")

    case "${___one}" in
        namespace)
            local ___source
            local ___name="$1"
            shift
            ___source="$(__ getsource "$*")"
            #shellcheck disable=SC2016
            eval '
            '"${___name}"' () (
                '"${___source}"'

                local ___one="$1"
                shift

                _"${___one}" "$@" || return $?
                return $?
            )'
            ;;
        getsource)
            (
                local f
                local fns
                local fone
                local ftwo
                local scripts=($1)
                fone="$(compgen -A function | sort)"
                __ import "${scripts[*]}"
                ftwo="$(compgen -A function | sort)"
                fns=($(comm -13 <(echo "${fone}") <(echo "${ftwo}")))

                for f in "${fns[@]}"
                do
                    declare -f "${f}"
                done
            )
            ;;

        import)
            local i
            local cwd
            local file
            local script
            local scripts=($1)
            local paths=(${MANAGEIMPORTPATHS[@]})
            local bashmagic="^(#!){1}.*(bash){1}.*"

            cwd="$(pwd)"

            for ((i=0;i<${#paths[@]};i++))
            do
                paths[i]="${paths[i]}/*"
            done

            for file in ${paths[*]}
            do
                for script in ${scripts[*]}
                do
                    if [[ "${script}" == "$(basename "${file}")"   ]] &&
                       [[ "$(head -n 1 "${file}")" =~ ${bashmagic} ]]
                    then
                        cd "$(dirname "${file}")"         || true
                        source "${file}" > /dev/null 2>&1 || true
                    fi
                done
            done
            cd "${cwd}" || exit
        esac
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]
then
    __ namespace "_" "${MANAGEIMPORT[*]}"
    __ import "libexec-instance-payload"
    [ -n "${MANAGESCRIPTPATH}" ] && source "${MANAGESCRIPTPATH}"
    _main "$@"
else

    resolvelink() {
        $(type -p greadlink readlink | head -1) "$1"
    }

    absolutedirectorypath() {
        local cwd
        local path="$1"

        cwd="$(pwd)"

        while [ -n "$path" ]; do
            cd "${path%/*}" || exit
            local name="${path##*/}"
            path="$(resolvelink "$name" || true)"
        done

        pwd
        cd "${cwd}" || exit
    }

    expandpath() {
        { cd "$(dirname "$1")" 2>/dev/null
            local dirname="$PWD"
            cd "$OLDPWD"
            echo "$dirname/$(basename "$1")"
        } || echo "$1"
    }

    # shellcheck disable=SC2034

    MANAGECWD="$(absolutedirectorypath .)"
    MANAGEZERO="$(expandpath "$0")"
    MANAGELIBEXEC="$(absolutedirectorypath "${MANAGEZERO}")"
    MANAGEDIRECTORY="$(absolutedirectorypath "${MANAGELIBEXEC}")"

    LC_ALL=C

    __ import "libexec-manage"

    __ namespace "_" "collection-shell"   \
                     "collection-array"   \
                     "collection-string"  \
                     "collection-grammar"

    checkdependencies "${MANAGEDIRECTORY}/libexec/manage"
    collectscripts "$@"
fi
