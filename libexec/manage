#!/usr/bin/env bash
#
# @doc manage is a convention for setting up shell programs that use subcommands.
#
# For more details on how to define your own commands
# look online at https://github.com/epiloque/manage
#
# @dependency tr
# @dependency head
# @dependency comm
# @dependency sed
# @dependency find

if ((BASH_VERSINFO[0] >= 4)) &&
   ((BASH_VERSINFO[1] >= 2))
then
    true
else
    echo "You need at least GNU bash, version 4.2" >&2
    exit 1
fi

strict()
{
    # set/unset strict mode
    #
    # Usage: strict true/false
    #

    local value
    value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
    case "${value}" in
        no|n|false|f|off|0)
            set   +o errexit
            set   +o errtrace
            set   +o pipefail
            shopt -u nullglob
            IFS=$' \n\t'
            ;;
        *)
            set   -o errexit
            set   -o errtrace
            set   -o pipefail
            shopt -s nullglob
            IFS=$'\n\t'
    esac
}

verbose()
{
    #
    # With no arguments, test if verbose mode is enabled.
    # With one argument, set/unset verbose mode.
    #

    if (( $# == 0 )); then
        [ -n "${MANAGEVERBOSE}" ] && return "${MANAGEVERBOSE}"
        return 1
    else
        local value
        value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
        case "${value}" in
            no|n|false|f|off|0)
                MANAGEVERBOSE=1
                ;;
            *)
                MANAGEVERBOSE=0
        esac
    fi
}

# MANAGE_MODULES=()
declare -A MANAGE_NAMESPACES
declare -A MANAGE_MODULES

MANAGE_BOOTSTRAP () {
    local namespace
    for namespace in "${!MANAGE_NAMESPACES[@]}"
    do
        MANAGE_CREATE_NAMESPACE "${namespace}" "${MANAGE_NAMESPACES[$namespace]}"
    done
}

_ () {
    local manage_namespace
    if [[ "$1" =~ ^@ ]]
    then
        true
        shift
    else
        manage_namespace="MANAGE_NAMESPACE_DEFAULT"
    fi

    "${manage_namespace}" "$@"
}

MANAGE_CREATE_NAMESPACE () {
    local manage_namespace="$1"
    local manage_namespace_source="$2"

    # echo "${manage_namespace_source}"
    # "${manage_namespace}" "$@" || return $?
    # return $?

    eval '
        '"${manage_namespace}"' () (
            strict true

            '"${manage_namespace_source}"'

            local ___func="$1"
            shift

            "${___func}" "$@" || return $?
            return $?
        )'
}

MANAGE_SOURCE () {
    (
        local f
        local fns
        local fone
        local ftwo
        local script="$1"
        fone="$(compgen -A function | sort)"
        source "${script}"
        ftwo="$(compgen -A function | sort)"
        fns=($(comm -13 <(echo "${fone}") <(echo "${ftwo}")))

        for f in "${fns[@]}"
        do
            declare -f "${f}"
        done
    )
}

MANAGE_NAMESPACE () {
    local module_namespace="$1"
    local module_file="$2"

    MANAGE_NAMESPACES[$module_namespace]+="$(MANAGE_SOURCE "$module_file")"$'\n'
}

MANAGE_TAG ()
{

    #TODO: import name regex
    local tag=${1//\//\\/}; shift
    local regex="^[#]\+[ \t]*@${tag} \(.*\)$"
    sed -n "s/${regex}/\1/p;s/^[ \t]*//;s/[ \t]*$//" "$@"
}

MANAGE_IMPORT () {
    [ -z "${MANAGEIMPORTPATHS}" ] && MANAGEIMPORTPATHS=("${MANAGEDIRECTORY}/modules")

    local bashmagic="^(#!){1}.*(bash){1}.*"
    local cwd
    local file
    local imports=()
    local mode="$1"
    shift
    local paths=(${MANAGEIMPORTPATHS[@]})
    local script
    local scripts=($@)
    local namespace

    cwd="$(pwd)"

    # TODO: performance
    # TODO: other namespaces
    while read -d '' -r file
    do
        for script in "${scripts[@]}"
        do
            if [[ -z "${MANAGE_MODULES["${script}"]}" ]] &&
               [[ "${file}" =~ ${script}$ ]] &&
               [[ "$(head -n 1 "${file}")" =~ ${bashmagic} ]] &&
               [[ "$(basename "${file}")" =~ ^[-a-zA-Z_]*$ ]]
            then
                imports+=($(MANAGE_TAG import "${file}"))
                MANAGE_MODULES["${script}"]="${file}"
                cd "$(dirname "${file}")"

                if [[ "${mode}" == "underscore" ]]
                then
                    if [[ "${file}" =~ ^${MANAGEDIRECTORY}/modules ]]
                    then
                        namespace="MANAGE_NAMESPACE_DEFAULT"
                    fi

                    MANAGE_NAMESPACE "${namespace}" "${file}" || ( echo "Failed to import '${file}'" && exit 1 )
                elif [[ "${mode}" == "local" ]]
                then
                    source "${file}" || ( echo "Failed to import '${file}'" && exit 1 )
                fi
            fi
        done
    done < <(find "${paths[*]}" -type f -print0)

    for script in "${scripts[@]}"
    do
        [ -z "${MANAGE_MODULES["${script}"]}" ] && ( echo "Failed to import '${script}'" && exit 1 )
    done

    if [ ! ${#imports[@]} -eq 0 ]
    then
        MANAGE_IMPORT "${mode}" "${imports[@]}"
    fi

    cd "${cwd}" || exit
}

MANAGE_LOCAL () {
    MANAGE_IMPORT local "$@"
}

MANAGE_UNDERSCORE () {
    MANAGE_IMPORT underscore "$@"
}

manage () {
    if [ "${MANAGEREPOSITORY}" == "${MANAGEDIRECTORY}" ]
    then
        "${MANAGEDIRECTORY}/libexec/manage" "$@"
    else
        "${MANAGEDIRECTORY}/libexec/manage" "${MANAGEREPOSITORY}" "$@"
    fi
}

MANAGE_ONCE () {
    local __code=0
    "$@" || __code="$?"
    eval "$1"' () { return '"${__code}"'; }'
    return "${__code}"
}

MANAGE_MAIN ()
{
    PATH="${MANAGEDIRECTORY}/vendor/bats/libexec:$PATH"
    local _code
    local _function
    if [ -n "${MANAGECOMPLETION}" ]
    then
        _function="completion"
    else
        _function="main"
    fi
    if declare -f "${_function}" > /dev/null 2>&1
    then
        trap 'MANAGE_ONCE MANAGE_RETURN $?' INT HUP TERM QUIT EXIT
        "${_function}" "$@"
        _code=$?
        trap - INT HUP TERM QUIT EXIT ERR
    fi

    MANAGE_ONCE MANAGE_RETURN "${_code}"
    return $?
}

MANAGE_RETURN ()
{
    # TODO: rename to onExit
    local _code=${1:-0}
    if declare -f "onexit" > /dev/null 2>&1
    then
        onexit "${_code}" || true
    fi

    return "${_code}"
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]
then
    MANAGE_IMPORT_ARRAY=(${MANAGEIMPORT})

    strict true

    if [ ! ${#MANAGE_IMPORT_ARRAY[@]} -eq 0 ]
    then
        MANAGE_UNDERSCORE "${MANAGE_IMPORT_ARRAY[@]}"
        MANAGE_BOOTSTRAP
    fi

    [ -n "${MANAGESCRIPTPATH}" ] &&
    source "${MANAGESCRIPTPATH}"
    MANAGE_MAIN "$@"
else
    strict true

    resolvelink() {
        $(type -p greadlink readlink | head -1) "$1"
    }

    absolutedirectorypath() {
        local cwd
        local path="$1"

        cwd="$(pwd)"

        while [ -n "$path" ]; do
            cd "${path%/*}" || exit
            local name="${path##*/}"
            path="$(resolvelink "$name" || true)"
        done

        pwd
        cd "${cwd}" || exit
    }

    expandpath() {
        { cd "$(dirname "$1")" 2>/dev/null
            local dirname="$PWD"
            cd "$OLDPWD"
            echo "$dirname/$(basename "$1")"
        } || echo "$1"
    }

    # shellcheck disable=SC2034

    MANAGECWD="$(absolutedirectorypath .)"
    MANAGEZERO="$(expandpath "$0")"
    MANAGELIBEXEC="$(absolutedirectorypath "${MANAGEZERO}")"
    MANAGEDIRECTORY="$(absolutedirectorypath "${MANAGELIBEXEC}")"

    LC_ALL=C

    SCRIPTPATHS=()
    SCRIPTNAMES=()

    MANAGE_LOCAL manage/checkFileDependencies manage/collectScripts

    checkFileDependencies "${MANAGEDIRECTORY}/libexec/manage"
    collectScripts "$@"
fi
