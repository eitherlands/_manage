#!/usr/bin/env bash
#
# <doc>
#
# _manage is a model for setting up shell programs that use
# subcommands.
#
# For more details on how to define your own commands look
# online at https://github.com/eitherlands/_manage
#
# </doc>
#
# <dependency>
#
# awk
# sed
# tr
# head
# grep
# comm
#
# </dependency>

if ((BASH_VERSINFO[0] < 4))
then
    echo "You need at least GNU bash, version 4." >&2
    exit 1
fi

strict()
{
    # set/unset strict mode
    #
    # Usage: strict true/false
    #

    local value
    value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
    case "${value}" in
        no|n|false|f|off|0)
            set   +o errexit
            set   +o errtrace
            set   +o pipefail
            shopt -u nullglob
            IFS=$' \n\t'
            ;;
        *)
            set   -o errexit
            set   -o errtrace
            set   -o pipefail
            shopt -s nullglob
            IFS=$'\n\t'
    esac
}

verbose()
{
    #
    # With no arguments, test if verbose mode is enabled.
    # With one argument, set/unset verbose mode.
    #

    if (( $# == 0 )); then
        # [[ ${MANAGEVERBOSE} ]] && return 0
        # return 1
        [ -n "${MANAGEVERBOSE}" ] && return "${MANAGEVERBOSE}"
        return 1
    else
        local value
        value="$(tr '[:upper:]' '[:lower:]' <<< "$1")"
        case "${value}" in
            no|n|false|f|off|0)
                MANAGEVERBOSE=1
                ;;
            *)
                MANAGEVERBOSE=0
        esac
    fi
}

__ ()
{
    local ___one="$1"
    shift

    [ -z "${MANAGEIMPORTPATHS}" ] && MANAGEIMPORTPATHS=("${MANAGEDIRECTORY}/common" "${MANAGEDIRECTORY}/payload")

    case "${___one}" in
        underscore)
            __ namespace "_" "$*"
            ;;
        namespace)
            local ___source
            local ___name="$1"
            shift
            ___source="$(__ getsource "$*")"

            #shellcheck disable=SC2016
            eval '
                '"${___name}"' () (
                    '"${___source}"'

                    local ___one="$1"
                    shift

                    _"${___one}" "$@" || return $?
                    return $?
                )'
            ;;
        getsource)
            (
                local f
                local fns
                local fone
                local ftwo
                local scripts=($1)
                fone="$(compgen -A function | sort)"
                __ import "${scripts[*]}"
                ftwo="$(compgen -A function | sort)"
                fns=($(comm -13 <(echo "${fone}") <(echo "${ftwo}")))

                for f in "${fns[@]}"
                do
                    declare -f "${f}"
                done
            )
            ;;

        import)
            local i
            local cwd
            local file
            local script
            local scripts=($1)
            local paths=(${MANAGEIMPORTPATHS[@]})
            local bashmagic="^(#!){1}.*(bash){1}.*"

            cwd="$(pwd)"

            for ((i=0;i<${#paths[@]};i++))
            do
                paths[i]="${paths[i]}/*"
            done

            for file in ${paths[*]}
            do
                for script in ${scripts[*]}
                do
                    if [[ "${script}" == "$(basename "${file}")"   ]] &&
                       [[ "$(head -n 1 "${file}")" =~ ${bashmagic} ]]
                    then
                        cd "$(dirname "${file}")"         || true
                        source "${file}" > /dev/null 2>&1 || true
                    fi
                done
            done
            cd "${cwd}" || exit
        esac
}

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]
then
    __ underscore "${MANAGEIMPORT[*]}"
    __ import "libexec-instance-payload"
    [ -n "${MANAGESCRIPTPATH}" ] && source "${MANAGESCRIPTPATH}"
    _main "$@"
else
    strict true

    resolvelink() {
        $(type -p greadlink readlink | head -1) "$1"
    }

    absolutedirectorypath() {
        local cwd
        local path="$1"

        cwd="$(pwd)"

        while [ -n "$path" ]; do
            cd "${path%/*}" || exit
            local name="${path##*/}"
            path="$(resolvelink "$name" || true)"
        done

        pwd
        cd "${cwd}" || exit
    }

    expandpath() {
        { cd "$(dirname "$1")" 2>/dev/null
            local dirname="$PWD"
            cd "$OLDPWD"
            echo "$dirname/$(basename "$1")"
        } || echo "$1"
    }

    # shellcheck disable=SC2034

    MANAGECWD="$(absolutedirectorypath .)"
    MANAGEZERO="$(expandpath "$0")"
    MANAGELIBEXEC="$(absolutedirectorypath "${MANAGEZERO}")"
    MANAGEDIRECTORY="$(absolutedirectorypath "${MANAGELIBEXEC}")"

    LC_ALL=C

    __ import "libexec-manage"

    __ underscore "collection-shell"   \
                  "collection-array"   \
                  "collection-string"  \
                  "collection-tag"

    checkdependencies "${MANAGEDIRECTORY}/libexec/manage"
    collectscripts "$@"
fi
