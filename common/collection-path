#!/usr/bin/env bash

[[ $COLLECTION_PATH_LOADED ]] && return

source collection-string

_commonpath()
{
    #
    # Gets the common path of the paths passed on stdin.
    # Alternatively, paths can be passed as arguments.
    #
    # Usage: _commonpath [PATH...]
    #

    local path

    # Make sure command line args go to stdin
    if (( $# > 0 )); then
        for path in "$@"; do
            echo "$path"
        done | _commonpath
        return
    fi

    local prefix
    prefix=$(
        while read -r; do
            echo "$(_abspath "$REPLY")/"
        done | _commonprefix
    )

    # We only want to break at path separators
    if [[ $prefix != */ ]]; then
        prefix=${prefix%/*}/
    fi

    # Only strip the trailing slash if it's not root (/)
    if [[ $prefix != / ]]; then
        prefix=${prefix%/}
    fi

    echo "$prefix"
}


# shellcheck disable=SC2120
_commontail()
{
    #
    # Gets the common tails of the paths passed on stdin.
    # Alternatively, paths can be passed as arguments.
    #
    # Usage: _commontail [PATH...]
    #
    # Usage examples:
    #     _commontail /foo/bar /boo/bar  #==> bar
    #     _commontail /foo/bar /boo/far  #==>
    #

    local path

    # Make sure command line args go to stdin
    if (( $# > 0 )); then
        # shellcheck disable=SC2119
        for path in "$@"; do
            echo "$path"
        done | _commontail
        return
    fi

    local suffix
    suffix=$(
        while read -r; do
            # shellcheck disable=SC2005
            echo "$(_abspath "$REPLY")"
        done | _commonsuffix
    )

    echo "${suffix#*/}"
}


_abspath()
{
    #
    # Gets the absolute path of the given path.
    # Will resolve paths that contain '.' and '..'.
    # Think readlink without the symlink resolution.
    #
    # Usage: _abspath [PATH]
    #

    local path=${1:-$PWD}

    # Path looks like: ~user/...
    # Gods of bash, forgive me for using eval
    if [[ $path =~ ~[a-zA-Z] ]]; then
        if [[ ${path%%/*} =~ ^~[[:alpha:]_][[:alnum:]_]*$ ]]; then
            path=$(eval echo "${path}")
        fi
    fi

    # Path looks like: ~/...
    [[ $path == ~* ]] && path=${path/\~/$HOME}

    # Path is not absolute
    [[ $path != /* ]] && path=$PWD/$path

    path=$(_squeeze "/" <<<"$path")

    local elms=()
    local elm
    local OIFS=$IFS; IFS="/"
    for elm in $path; do
        IFS=$OIFS
        [[ $elm == . ]] && continue
        if [[ $elm == .. ]]; then
            elms=("${elms[@]:0:$((${#elms[@]}-1))}")
        else
            elms=("${elms[@]}" "$elm")
        fi
    done
    IFS="/"
    echo "/${elms[*]}"
    IFS=$OIFS
}

_relpath()
{
    #
    # Gets the relative path from SOURCE to DESTINATION.
    # Output should mirror the python function os.path.relpath().
    # All arguments default to the current directory.
    #
    # Usage: _relpath [DESTINATION] [SOURCE]
    #
    # Usage examples:
    #     _relpath /home/user     /home/user/bin  #==> bin
    #     _relpath /home/user/bin /home/user      #==> ..
    #     _relpath /foo/bar/baz   /               #==> ../../..
    #     _relpath /foo/bar       /baz            #==> ../../baz
    #     _relpath /home/user     /home/user      #==> .
    #     _relpath                                #==> .
    #

    local dst
    local src
    local common
    dst=$(_abspath "$1")
    src=$(_abspath "$2")
    common=$(_commonpath "$dst" "$src")

    dst=${dst#$common}; dst=${dst#/}
    src=${src#$common}; src=${src#/}

    local OIFS=$IFS; local IFS=/
    src=($src)
    IFS=$OIFS

    local rel=
    # shellcheck disable=SC2034
    for i in "${!src[@]}"; do
        rel+=../
    done

    rel=${rel}${dst}

    # Handle some corner cases.
    # Arguments were the same path.
    [[ $rel ]] || rel=.
    # Make sure there are no trailing slashes.
    # ...except for root.
    [[ $rel == / ]] || rel=${rel%%/}

    echo "$rel"
}

COLLECTION_PATH_LOADED=1
