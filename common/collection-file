#!/usr/bin/env bash

# Filename:      collection-files
# Description:   Miscellaneous utility functions for dealing with files.

[[ $COLLECTION_FILES_LOADED ]] && return

source collection-message
source collection-shell
source collection-string

# __normalize_path () {
#     # Remove all /./ sequences.
#     local path=${1//\/.\//\/}
#
#     # Remove dir/.. sequences.
#     while [[ $path =~ ([^/][^/]*/\.\./) ]]
#     do
#         path=${path/${BASH_REMATCH[0]}/}
#     done
#     echo "${path}"
# }
#
# __validate_path () {
#     local regex='^(/)?([^/\0]+(/)?)+$'
#
#     if [[ $1 =~ $regex ]]
#     then
#         return 0
#     else
#         return 1
#     fi
# }

_commonpath()
{
    #
    # Gets the common path of the paths passed on stdin.
    # Alternatively, paths can be passed as arguments.
    #
    # Usage: _commonpath [PATH...]
    #

    local path

    # Make sure command line args go to stdin
    if (( $# > 0 )); then
        for path in "$@"; do
            echo "$path"
        done | _commonpath
        return
    fi

    local prefix=$(
    while read -r; do
        echo "$(_abspath "$REPLY")/"
    done | _commonprefix
    )

    # We only want to break at path separators
    if [[ $prefix != */ ]]; then
        prefix=${prefix%/*}/
    fi

    # Only strip the trailing slash if it's not root (/)
    if [[ $prefix != / ]]; then
        prefix=${prefix%/}
    fi

    echo "$prefix"
}

_commontail()
{
    #
    # Gets the common tails of the paths passed on stdin.
    # Alternatively, paths can be passed as arguments.
    #
    # Usage: _commontail [PATH...]
    #
    # Usage examples:
    #     _commontail /foo/bar /boo/bar  #==> bar
    #     _commontail /foo/bar /boo/far  #==>
    #

    local path

    # Make sure command line args go to stdin
    if (( $# > 0 )); then
        for path in "$@"; do
            echo "$path"
        done | _commontail
        return
    fi

    local suffix=$(
    while read -r; do
        echo "$(_abspath "$REPLY")"
    done | _commonsuffix
    )

    echo "${suffix#*/}"
}

_extname()
{
    #
    # Get the extension of the given filename.
    #
    # Usage: _extname [-n LEVELS] FILENAME
    #
    # Usage examples:
    #     _extname     foo.txt     #==> .txt
    #     _extname -n2 foo.tar.gz  #==> .tar.gz
    #     _extname     foo.tar.gz  #==> .tar.gz
    #     _extname -n1 foo.tar.gz  #==> .gz
    #

    local levels

    unset OPTIND
    while getopts ":n:" option; do
        case $option in
            n) levels=$OPTARG ;;
        esac
    done && shift $(($OPTIND - 1))

    local filename=${1##*/}

    [[ $filename == *.* ]] || return

    local fn=$filename
    local exts ext

    # Detect some common multi-extensions
    if [[ ! $levels ]]; then
        case $(_lower <<<$filename) in
            *.tar.gz|*.tar.bz2) levels=2 ;;
        esac
    fi

    levels=${levels:-1}

    for (( i=0; i<$levels; i++ )); do
        ext=.${fn##*.}
        exts=$ext$exts
        fn=${fn%$ext}
        [[ $exts == $filename ]] && return
    done

    echo "$exts"
}

_filename()
{
    #
    # Gets the filename of the given path.
    #
    # Usage: _filename [-n LEVELS] FILENAME
    #
    # Usage examples:
    #     _filename     /path/to/file.txt     #==> file
    #     _filename -n2 /path/to/file.tar.gz  #==> file
    #     _filename     /path/to/file.tar.gz  #==> file
    #     _filename -n1 /path/to/file.tar.gz  #==> file.tar
    #

    basename "$1" $(_extname "$@")
}

_increment()
{
    #
    # Get the next filename in line for the given file.
    #
    # Usage: _increment FILENAME
    #
    # Usage examples:
    #     _increment does_not_exist  #==> does_not_exist
    #     _increment does_exist      #==> does_exist (1)
    #     _increment does_exist      #==> does_exist (2)
    #

    local file=$1
    local count=1
    local pattern=${2:- (\{num\})}

    while [[ -e $file ]]; do
        file="${1}${pattern//\{num\}/$((count++))}"
    done

    echo "$file"
}

_listdir()
{
    #
    # List the files in the given directory (1 level deep).
    # Accepts the same options as the find command.
    #
    # Usage: _listdir DIR [OPTIONS]
    #

    local dir=$1; shift
    find "$dir" -maxdepth 1 -mindepth 1 "$@"
}

_files()
{
    #
    # List all the files in the given directory (recursively).
    # Will not display hidden files.
    # Accepts the same options as the find command.
    #
    # Usage: _files DIR [OPTIONS]
    #

    local dir=$1; shift
    find "$dir" \( -type f -o -type l \) \! -wholename "*/.*" "$@"
}

_abspath()
{
    #
    # Gets the absolute path of the given path.
    # Will resolve paths that contain '.' and '..'.
    # Think readlink without the symlink resolution.
    #
    # Usage: _abspath [PATH]
    #

    local path=${1:-$PWD}

    # Path looks like: ~user/...
    # Gods of bash, forgive me for using eval
    if [[ $path =~ ~[a-zA-Z] ]]; then
        if [[ ${path%%/*} =~ ^~[[:alpha:]_][[:alnum:]_]*$ ]]; then
            path=$(eval echo $path)
        fi
    fi

    # Path looks like: ~/...
    [[ $path == ~* ]] && path=${path/\~/$HOME}

    # Path is not absolute
    [[ $path != /* ]] && path=$PWD/$path

    path=$(_squeeze "/" <<<"$path")

    local elms=()
    local elm
    local OIFS=$IFS; IFS="/"
    for elm in $path; do
        IFS=$OIFS
        [[ $elm == . ]] && continue
        if [[ $elm == .. ]]; then
            elms=("${elms[@]:0:$((${#elms[@]}-1))}")
        else
            elms=("${elms[@]}" "$elm")
        fi
    done
    IFS="/"
    echo "/${elms[*]}"
    IFS=$OIFS
}

_relpath()
{
    #
    # Gets the relative path from SOURCE to DESTINATION.
    # Output should mirror the python function os.path.relpath().
    # All arguments default to the current directory.
    #
    # Usage: _relpath [DESTINATION] [SOURCE]
    #
    # Usage examples:
    #     _relpath /home/user     /home/user/bin  #==> bin
    #     _relpath /home/user/bin /home/user      #==> ..
    #     _relpath /foo/bar/baz   /               #==> ../../..
    #     _relpath /foo/bar       /baz            #==> ../../baz
    #     _relpath /home/user     /home/user      #==> .
    #     _relpath                                #==> .
    #

    local dst=$(_abspath "$1")
    local src=$(_abspath "$2")

    local common=$(_commonpath "$dst" "$src")

    dst=${dst#$common}; dst=${dst#/}
    src=${src#$common}; src=${src#/}

    local OIFS=$IFS; local IFS=/
    src=($src)
    IFS=$OIFS

    local rel=
    for i in "${!src[@]}"; do
        rel+=../
    done

    rel=${rel}${dst}

    # Handle some corner cases.
    # Arguments were the same path.
    [[ $rel ]] || rel=.
    # Make sure there are no trailing slashes.
    # ...except for root.
    [[ $rel == / ]] || rel=${rel%%/}

    echo "$rel"
}

_link()
{
    #
    # Version of ln that respects the verbose settings.
    #
    # Usage: _link SOURCE [DESTINATION]
    #

    _verbose     ${VERBOSE:-1}
    $SUDO ln -snT $(_echo -v) "$@"
}

_linkrel()
{
    #
    # Like link, but uses relpath to make the paths relative.
    #
    # Usage: _linkrel SOURCE [DESTINATION]
    #

    local dir=$(_relpath "${@%/*}")/
    dir=${dir##./}
    _link "${dir}${1##*/}" "$2"
}

_move()
{
    #
    # Version of mv that respects the verbose settings.
    # Accepts the same options/arguments as mv.
    #

    _verbose     ${VERBOSE:-1}

    $SUDO mv -T $(_echo -v) "$@"
}

_copy()
{
    #
    # Version of cp that respects the verbose settings.
    # Accepts the same options/arguments as cp.
    #

    # _verbose     "${VERBOSE:-1}"

    $SUDO cp -Tr"$(_echo v)" "$@"
}

_stow()
{
    #
    # Replicate a directory tree and link regular files.
    #

    local src=$1
    local dst=${2:-$PWD}

    local OIFS=$IFS; IFS=$'\n'
    for f in $(files "$src"); do
        IFS=$OIFS
        local nf=$dst/${f#$src/}
        mkdir -p "$(dirname "$nf")"
        _linkrel "$f" "$nf"
    done
}

_remove()
{
    #
    # Version of rm that respects the verbose settings.
    # Accepts the same options/arguments as rm.
    #

    _verbose     ${VERBOSE:-1}

    $SUDO rm -r $(_echo -v) "$@"
}

_cleanup()
{
    #
    # Cleans up any temp files lying around.
    # Intended to be used alongside _tempfile() and not to be called directly.
    #

    for file in "${CLEANUP_FILES[@]}"; do
        $SUDO rm -rf "$file"
    done
}

_tempfile()
{
    #
    # Creates and keeps track of temp files.
    #
    # Usage examples:
    #     _tempfile    # $TEMPFILE is now a regular file
    #

    TEMPFILE=$(mktemp "$@")
    if [[ ! $TEMPFILE ]]; then
        _error "Could not create temporary file."
        return 1
    fi
    CLEANUP_FILES=("${CLEANUP_FILES[@]}" "$TEMPFILE")
    trap _cleanup INT TERM EXIT
}

_tempdir()
{
    #
    # Creates and keeps track of temp directories.
    #
    # Usage examples:
    #     _tempdir    # $TEMPDIR is now a directory
    #

    _tempfile -d -t "$(basename "$0").XXXXXX"
    TEMPDIR=$TEMPFILE
}

_truncate()
{
    # Removes all similar unused files.
    # The only assumption is that the prefix is separated from the identifier
    # by a single hyphen (-).
    #
    # Usage: _truncate PREFIX SUFFIX [EXCLUDED_PREFIX...]
    #
    # Usage examples:
    #
    # Given the following files:
    #
    #     file.txt -> file-c.txt
    #     file-a.txt
    #     file-b.txt
    #     file-c.txt
    #
    # The following command:
    #
    #     _truncate file .txt
    #
    # Will leave only the following files:
    #
    #     file.txt -> file-c.txt
    #     file-c.txt
    #
    # If you have other files with similar prefixes they will be removed as
    # well. For example, if we also had the following files:
    #
    #     file-foo-a.txt
    #     file-foo-b.txt
    #     file-bar-a.txt
    #     file-bar-b.txt
    #
    # If you want to keep these files, you will have to pass exclusions like:
    #
    #     _truncate file .txt file-foo file-bar

    local prefix=$1; shift
    local suffix=$1; shift
    local filename=$prefix$suffix

    # There is no symlink to follow
    if [[ ! -L $filename ]]; then
        _error "Name not provided or does not exist as a symlink."
        return 1
    fi

    # Get the file to NOT remove
    local target=$(readlink -f "$filename")

    if [[ ! -e $target ]]; then
        _error "Target file does not exist."
        return 1
    fi

    local dir=$(dirname "$target")
    local file fn exclude

    for file in "$dir"/$(basename "$prefix")-*$suffix; do
        [[ -f $file ]] || continue
        fn=${file##*/}
        # Make sure file doesn't match an exclusion
        for exclude in "$@"; do
            [[ $fn == $exclude* ]] && continue
        done
        if [[ $file != $target ]]; then
            _remove "$file"
        fi
    done
}

_findAbove()
{
    #
    # Find the nearest file/directory above the current directory.
    # Takes the same options as find.
    #
    # Usage: _findAbove [OPTIONS]
    #

    local OPWD=$PWD
    local result
    while true; do
        find "$PWD" -maxdepth 1 -mindepth 1 "$@"
        [[ $PWD == / ]] && break
        cd ..
    done
    cd "$OPWD"
}

COLLECTION_FILES_LOADED=1
