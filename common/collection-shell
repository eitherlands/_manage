#!/usr/bin/env bash

# Filename:      collection-shell
# Description:   Miscellaneous utility functions.
#

[[ $COLLECTION_SHELL_LOADED ]] && return

source collection-string

_first()
{
    #
    # Get the first value that is non-empty.
    #
    # Usage examples:
    #     EDITOR=$(_first "$VISUAL" "$EDITOR" vi)
    #

    local value
    for value in "$@"; do
        if [[ $value ]]; then
            echo "$value"
            return 0
        fi
    done
    return 1
}

_named()
{
    #
    # Get the value of the variable named the passed argument.
    #
    # The only reason why this function exists is because I can't do:
    #
    #     echo ${!"some_var"}
    #
    # Instead, I have to do:
    #
    #     some_var="The value I really want"
    #     name="some_var"
    #     echo ${!name}  #==> The value I really want
    #
    # With _named(), I can now do:
    #
    #     some_var="The value I really want"
    #     _named "some_var"  #==> The value I really want
    #
    # Which eliminates the need for an intermediate variable.
    #

    echo "${!1}"
}

_truth()
{
    #
    # Determine the "truthiness" of the given value.
    #
    # Usage examples:
    #     _truth True   #==> true
    #     _truth        #==> false
    #     _truth 1      #==> true
    #     _truth false  #==> false
    #     _truth on     #==> true
    #     _truth spam   #==> false
    #

    case $(_lower <<<"$1") in
        yes|y|true|t|on|1) return 0 ;;
    esac
    return 1
}

_truthEcho()
{
    #
    # Depending on the "truthiness" of the given value, echo the first (true)
    # or second (false) value.
    #

    if _truth "$1"; then
        [[ $2 ]] && echo "$2"
    else
        [[ $3 ]] && echo "$3"
    fi
}

_truthValue()
{
    #
    # Gets a value that represents the "truthiness" of the given value.
    #

    _truthEcho "$1" 1 0
}

_execute()
{
    #
    # Execute a given command.
    #
    # Usage: _execute [ARGUMENT...]
    #

    bash --norc --noprofile -c "$@" || return $?
}

_executeIn()
{
    #
    # Execute a command in a given directory.
    #
    # Usage: _executeIn DIRECTORY [COMMAND...]
    #

    local error
    local OPWD=$PWD
    cd "$1" || return 1
    shift
    _execute "$@"; error=$?
    cd "$OPWD" || return 1
    return $error
}

_repeat()
{
    #
    # Repeat a command a given number of times.
    #

    local count=$1; shift
    local i
    for i in $(seq 1 "${count}"); do
        "$@"
    done
}

_required() {
    local i
    for i in "$@"
    do
        [ -z "${i// }" ] && return 1
    done
    return 0
}

__exists () {
    _required "$1" || return 0
    which "$1" &> /dev/null
    return "$?"
}

_exists () {
    _required "$1" || return 0
    local dependency
    local index=0
    for dependency in "$@"
    do
        __exists "${dependency}" || return "$((index+1))"
        index=$((index+1))
    done
}

COLLECTION_SHELL_LOADED=1
