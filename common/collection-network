#!/usr/bin/env bash

# Filename:      collection-network
# Description:   Network helpers

[[ $COLLECTION_NETWORK_LOADED ]] && return

source collection-string
source collection-shell
source collection-array

__mc ()
{
    local i
    local len
    local OIFS
    OIFS=$IFS
    IFS=.
    for i in $1; do
        while [ "${i}" != "0" ]; do
            len=$((len + i % 2))
            i=$((i >> 1))
        done
    done

    IFS=$OIFS
    echo "${len}"
}

__cm() {
    local i mask=""
    local full_octets=$(($1/8))
    local partial_octet=$(($1%8))

    for ((i=0;i<4;i+=1)); do
        if [ $i -lt $full_octets ]; then
            mask+=255
        elif [ $i -eq $full_octets ]; then
            mask+=$((256 - 2**(8-partial_octet)))
        else
            mask+=0
        fi
        test $i -lt 3 && mask+=.
    done

    echo $mask
}

__atoi () {
    local oc
    oc=( $(echo "$1" | sed 's/\./\n/g' | sed 's/\//\n/g' ) )
    echo "$((oc[0] * 256 ** 3 + oc[1] * 256 ** 2 + oc[2] * 256 + oc[3]))"
}

__itoa () {
    echo -n $(($(($(($((${1}/256))/256))/256))%256)).
    echo -n $(($(($((${1}/256))/256))%256)).
    echo -n $(($((${1}/256))%256)).
    echo $((${1}%256))
}

__mask() {
    _required "$1" "$2" || return 1
    local oc
    local regexIp
    local regexMask
    regexIp="^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
    regexMask="^(((255\.){3}(255|254|252|248|240|224|192|128|0+))|((255\.){2}(255|254|252|248|240|224|192|128|0+)\.0)|((255\.)(255|254|252|248|240|224|192|128|0+)(\.0+){2})|((255|254|252|248|240|224|192|128|0+)(\.0+){3}))$"

    if [[ "$1" =~ ${regexIp} ]] && [[ "$2" =~ ${regexMask} ]]
    then
        oc=( $(echo "$1" | sed 's/\./\n/g' | sed 's/\//\n/g' ) )
        if [[ ! (( "${oc[0]}" -eq 0  ||
            "${oc[0]}" -gt 255 ) ||
            "${oc[1]}" -gt 255   ||
            "${oc[2]}" -gt 255   ||
            "${oc[3]}" -gt 255 ) ]]
    then
        echo -e "${oc[0]}.${oc[1]}.${oc[2]}.${oc[3]}\n$2"
        return 0
    else
        return 1
    fi
else
    return 1
fi
}

__cidr() {
    _required "$1" || return 1
    local oc
    local regex
    regex='^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$'

    if [[ "$1" =~ ${regex} ]]
    then
        oc=( $(echo "$1" | sed 's/\./\n/g' | sed 's/\//\n/g' ) )
        if [[ ! (( "${oc[0]}" -eq 0  ||
            "${oc[0]}" -gt 255 ) ||
            "${oc[1]}" -gt 255   ||
            "${oc[2]}" -gt 255   ||
            "${oc[3]}" -gt 255   ||
            "${oc[4]}" -gt 32  ) ]]
    then
        echo -e "${oc[0]}.${oc[1]}.${oc[2]}.${oc[3]}\n$(__cm "${oc[4]}")"
        return 0
    else
        return 1
    fi
else
    return 1
fi
}

_ipcalc () {
    _required "$1" "$2" || return 1

    local mode
    local array
    local ip
    local mask
    local prefix
    local broadcast
    local network
    local diff
    local noip
    local ipint
    local ipmask
    local ipstart
    local ipend
    local commands
    local command

    commands=("address"
    "netmask"
    "prefix"
    "network"
    "hostmin"
    "hostmax"
    "broadcast"
    "hosts"
    "range")

    if _includes "commands" "$1"
    then
        command="$1"
        shift
        if _required "$1" "$2"
        then
            mode="__mask"
        else
            mode="__cidr"
        fi
        array=($("${mode}" "${@}"))
        if [[ $? == 0 ]]
        then
            ip="${array[0]}"
            mask="${array[1]}"
            prefix="$(__mc "${mask}")"
            diff=$((32-prefix))
            noip=$((2**diff))
            ipint="$(__atoi "${ip}")"
            ipmask=$((ipint & (2**32 - 2**diff)))
            ipstart="${ipmask}"
            ipend=$((ipmask+noip-1))
            network="$(__itoa "${ipmask}")"

            if [[ ${prefix} == "32" ]] || [[ ${prefix} == "31" ]]
            then
                hosts=$((noip))
                first="$(__itoa $((ipstart)))"
                last="$(__itoa $((ipend)))"
                broadcast=""
            else
                hosts=$((noip-2))
                first="$(__itoa $((ipstart+1)))"
                last="$(__itoa $((ipend-1)))"
                broadcast="$(__itoa "${ipend}")"
            fi

            case "${command}" in
                address)
                    echo "${ip}"
                    ;;
                netmask)
                    echo "${mask}"
                    ;;
                prefix)
                    echo "${prefix}"
                    ;;
                network)
                    echo "${network}/${prefix}"
                    ;;
                hostmin)
                    echo "${first}"
                    ;;
                hostmax)
                    echo "${last}"
                    ;;
                broadcast)
                    echo "${broadcast}"
                    ;;
                hosts)
                    echo "${hosts}"
                    ;;
                range)
                    local current
                    local ending
                    if [[ ${prefix} == "32" ]] || [[ ${prefix} == "31" ]]
                    then
                        current="${ipstart}"
                        ending="${ipend}"
                    else
                        current="$((ipstart+1))"
                        ending="$((ipend-1))"
                    fi
                    while [[ "${current}" -le "${ending}" ]]
                    do
                        __itoa "${current}"
                        current=$((current+1))
                    done

            esac
            return 0
        else
            return 1
        fi
    fi
}

COLLECTION_NETWORK_LOADED=1
